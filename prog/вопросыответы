---

### 1. Математические операции

В Python арифметика строится вокруг **операций над объектами**, а не над переменными как таковыми. Базовые операторы `+ - * / // % **` перегружены методами `__add__`, `__sub__` и т. д., поэтому одно и то же выражение будет работать с числами (`int`, `float`, `Decimal`) и, например, с объектами `datetime`. Целочисленное деление `//` возвращает математический пол, тогда как обычное `/` — число с плавающей точкой. Порядок вычислений соответствует PEMDAS, но скобки придают выражению наглядность и ускоряют чтение кода. Для точных финансовых расчётов используют `decimal.Decimal`; для работы с большими целыми — `int`, который автоматически расширяется. Модуль `math` дополняет базовый набор функциями тригонометрии, логарифмами и константами (`pi`, `e`). С Python 3.11 появился `math.nextafter`, позволяющий точно контролировать переход к ближайшему представимому числу IEEE-754.

---

### 2. Скалярные типы данных

К скалярам относят **`int`**, **`float`**, **`complex`**, **`bool`** и `NoneType`.

* `int` — произвольной разрядности, автоматически переключается из формата C-long в «big int».
* `float` — 64-битный IEEE-754 «double»; помните о погрешности `0.1 + 0.2 != 0.3`.
* `complex` — пара `float`-ов, доступ к частям через `.real` и `.imag`.
* `bool` — подкласс `int`, поэтому `True + True == 2`.
* `NoneType` имеет единственный экземпляр `None`, играющий роль «пустого» значения.
  Все скаляры **иммутабельны**: любые «изменения» создают новый объект. Тип можно узнать функцией `type`, а проверить — `isinstance`. Преобразования выполняют встроенные конструкторы: `int("42")`, `float(3)`. Для безопасного перевода строк в числа используйте обработку исключений `try/except ValueError`.

---

### 3. Составные типы данных

Составными называют **контейнеры**, хранящие другие объекты:

* **`list`** (изменяемый массив),
* **`tuple`** (иммутабельная упорядоченная коллекция),
* **`set` / `frozenset`** (множества),
* **`dict`** (ассоциативный массив).
  Общие черты: итерируемость, поддержка `len`, `in`, `for`; различия — во внутренней структуре и гарантиях порядка. С Python 3.7 словари сохраняют порядок вставки, но это **не часть** математической модели dict — лишь деталь реализации. Для экономии памяти доступны массивы из модуля `array`, а для численных задач — `numpy.ndarray`.

---

### 4. Операторы `if/elif/else`, `for`, `while`, `in`, `for/else`

* **`if`** проверяет истинность выражения; блоки определяются отступами.
* **`elif`** (else if) избегает каскадов `if` в `if`.
* **`else`** выполняется, когда ни один `if/elif` не сработал.
* **`while`** — цикл с предусловием; опасайтесь бесконечных итераций.
* **`for`** — итерирует объект, запрашивая итератор через `iter()` и `next()`.
* **`in`** выступает оператором членства и частью `for`.
* **`for … else`**: блок `else` выполняется, если цикл завершился **без** `break`. Пригодится для поиска элемента: если не найден — срабатывает `else`.

---

### 5. Последовательности и функции работы с ними

Последовательности включают **строки, списки, кортежи, range, bytes**. Общий протокол: индексирование `s[i]`, срезы `s[a:b:c]`, функция `len`. Встроенные помощники:

* `enumerate(seq, start=0)` — пары `(индекс, значение)`.
* `zip(*iters, strict=False)` — «молния» нескольких последовательностей.
* `reversed(seq)` — обратный итератор, требует реализации `__reversed__` или поддерживает random-access.
* `sorted(iterable, key=…, reverse=True)` — возвращает новый список.
* `any`, `all`, `sum`, `min`, `max` — агрегаторы.
  List-comprehension `[x*x for x in range(10) if x % 2]` читабельнее, чем привычный цикл и создаёт новый список.

---

### 6. Булевый тип данных

`bool` — наследник `int` с двумя константами `True` и `False`. Любой объект имеет **логическое значение**, возвращаемое `bool(obj)`, которое по умолчанию — `True`, если объект не равен 0 / пустой / `None`. Магические методы:

* `__bool__(self)` — явное преобразование;
* `__len__` — как fallback (0 → False).
  Короткое замыкание (`and`, `or`) даёт не обязательно булевы, а сам **последний проверенный** операнд.

---

### 7. Множества и функции работы с ними

`set` — **неупорядоченная** коллекция уникальных хешируемых объектов. Поддерживает операции теории множеств:

* `|`, `&`, `-`, `^` (объединение, пересечение, разность, симм. разность).
* Методы проверки: `issubset`, `issuperset`, `isdisjoint`.
* Изменяющие варианты: `update`, `intersection_update`.
  `frozenset` — иммутабельный собрат, используется как ключи словаря. Ради скорости Python хранит set в таблице hash-значений с открытой адресацией.

---

### 8. Отображения (словари)

`dict` хранит пары «ключ → значение», ключ должен быть хешируемым (`__hash__`, `__eq__`). С версии 3.7 порядок вставки гарантирован. Частые методы:

* `get(k, default=None)` — безопасный доступ, не бросает `KeyError`.
* `setdefault` — «выдай и запомни».
* `items`, `keys`, `values` — **views**, динамически отражающие изменения.
  `collections.defaultdict` автоматически создаёт элемент по `default_factory`. Для счётчиков пользуйтесь `collections.Counter`.

---

### 9. Строки и операции над ними

`str` — неизменяемая последовательность **Unicode-кодовых точек**. Основные операции:

* конкатенация `+`, умножение на число `*`,
* поиск `find`, `index`, `in`,
* изменение регистра `lower`, `upper`, `casefold`,
* разбиение `split`, `rsplit`, `partition`,
* выравнивание `center`, `ljust`, `rjust`,
* `replace`, `strip`/`lstrip`/`rstrip`.
  `bytes` и `bytearray` — последовательности 0-255; перевод строк в байты — `.encode("utf-8")`, обратно — `.decode()`.

---

### 10. Форматный ввод-вывод (`f-строки`, `str.format`, `%`)

* **F-строки** (3.6+) — интерполяция на уровне байткода:

  ```python
  name, bal = "Ира", 2_500
  print(f"{name=:^10} → {bal:,.2f} ₽")
  ```

  Внутри допускается мини-выражение и формат-спецификатор.
* **`str.format`** старше, но полезен при динамическом выборе полей:
  `"Число {0:b} = {0}".format(42)`
* **Оператор `%`** — наследие C: `%d`, `%s`; избегайте со словарями (опасно для SQL-инъекций).
  Форматы совместимы с `format()` и `__format__`.

---

### 11. Функции

Определяются `def` или `lambda`. Объекты **первого класса** — можно передавать, хранить, возвращать.

* Позиционные, именованные, `*args`, `**kwargs`.
* Аннотации PEP-484 — подсказки типов, не строгая проверка.
* Замыкания: у вложенной функции есть доступ к лексическому окружению (ключевое слово `nonlocal` для изменения).
* Декораторы — функции, принимающие другую функцию и возвращающие обёртку.
  Рекурсия ограничена стеком (`sys.getrecursionlimit`).

---

### 12. Управление памятью

Python использует **счётчик ссылок** + циклический **генератор мусора** (GC). Когда `refcount == 0`, объект мгновенно освобождается; циклические ссылки удаляет GC-пауза поколения `gc.collect()`. PEP 445 описывает кастомные аллокаторы; однако стандартно память выделяет `pymalloc`. Разумно контролировать крупные структуры через `del` или присваивание `None`. Контекст-менеджеры (`with`) помогают гарантированно закрывать ресурсы.

---

### 13. Виртуальная среда и менеджер пакетов

`python -m venv .env` создаёт **изолированную** папку с копией интерпретатора и `pip`. Активация (`source .env/bin/activate` или `.\env\Scripts\activate`). Пакеты ставятся `pip install`, зависимости фиксируются в `pyproject.toml` (PEP-621) или `requirements.txt`. Для сложных проектов применяют `poetry`, `pipenv`, `conda`.

---

### 14. Открытие и закрытие файлов

Функция `open(path, mode="r", encoding="utf-8")` возвращает объект-файл, реализующий протокол **IOBase**. Важно закрывать файл (`f.close()`), иначе дескриптор останется в операционной системе. Ошибка доступа отражается исключениями `FileNotFoundError`, `PermissionError`.

---

### 15. Обход файла

Чтение небольших файлов — `data = f.read()`. Для больших используют:

```python
for line in f:          # ленивое чтение
    process(line.rstrip())
```

или `f.readline()`, `f.readlines(sizehint)`. Побайтовый доступ предоставляет `f.readinto(buffer)`.

---

### 16. Оператор `with`

`with open("log.txt") as f:` создаёт контекст-менеджер, вызывающий `__enter__` (получение ресурса) и `__exit__` (освобождение, даже при исключении). Реализовать собственный можно через класс или декоратор `contextlib.contextmanager`.

---

### 17. ООП: класс, объект, наследование, переменные класса

Класс — шаблон, объект — экземпляр. Наследование выражается в скобках:

```python
class Child(Parent): pass
```

Атрибуты, заданные **на уровне класса**, общие для всех экземпляров; изменение через экземпляр создаёт одноимённый атрибут в `__dict__` объекта, не трогая класс. Множественное наследование разрешено; порядок поиска MRO описан алгоритмом C3 (см. `class.mro()`).

---

### 18. Метод `__init__`, понятие `self`

`__init__` вызывается сразу после выделения памяти (`__new__`) и заполняет объект начальными данными. Первый параметр `self` — ссылка на создающийся экземпляр; имя не специальное, но по PEP-8 используйте именно `self`.

---

### 19. Протокол итерации

Объект итеративен, если реализует `__iter__`, возвращающий итератор, то есть объект с методом `__next__`. При исчерпании бросается `StopIteration`. Генераторы (`yield`) автоматически создают такие объекты, а `yield from` делегирует подпотоку.

---

### 20. Взаимодействие с C++

* **CPython C-API**: пишем расширение на C/C++ и компилируем.
* **pybind11**: современный заголовочный подход, превращает C++-классы в Python-классы.
* **CFFI / ctypes**: связывание с готовыми `.so/.dll`.
* **SWIG**: генерация обвязки для множества языков.
  Решение выбирают по требованиям к скорости, удобству сборки и поддержке исключений C++.

---

### 21. `ctypes`: пример

```python
import ctypes
libm = ctypes.CDLL("libm.so.6")     # Linux
libm.cos.restype = ctypes.c_double
libm.cos.argtypes = [ctypes.c_double]
print(libm.cos(0.0))                # 1.0
```

Мы загружаем системную `libm`, описываем типы аргументов и вызываем функцию как обычный питоновский объект. Помните о разрядности и выборе ABI (`cdecl`/`stdcall`).

---

### 22. Виды интерфейсов

* **CLI** (командная строка) — скрипты, `argparse`, `click`.
* **GUI** — настольные окна (Qt, Gtk, Tk).
* **Web-интерфейс** — браузер + сервер (Flask, Django).
* **API** — программный уровень (REST, gRPC).
  Выбор зависит от целей, аудитории и платформ.

---

### 23. Графический интерфейс: UI/UX, этапы, золотое сечение

**UI** — визуальный слой, **UX** — впечатления пользователя. Процесс:

1. Исследование потребностей (Personas, Jobs-to-Be-Done).
2. Wireframes — «скелет» экранов.
3. Прототипирование и тестирование.
4. Визуальный дизайн (цвет, типографика, иконки).
5. Передача в разработку и поддержка.
   При компоновке используют правила композиции: сетка 8-pt, правило третей и **золотое сечение ≈ 1.618** для пропорций карточек, отступов, шрифтов — создаёт гармонию и снижает когнитивную нагрузку.

---

### 24. PyQt: основы

```python
from PyQt6.QtWidgets import QApplication, QLabel
app = QApplication([])
lbl = QLabel("Привет, PyQt!")
lbl.resize(200, 60)
lbl.show()
app.exec()
```

PyQt предоставляет **сигналы и слоты** для событий, богатый набор виджетов и Qt Designer для визуальной верстки. Главное окно — класс-наследник `QMainWindow`; размещение контролов через `QLayout`.

---

### 25. Основы `pytest`

`pytest` обнаруживает функции `test_*`, использует «голые» `assert`-ы (плагин-rewriter разворачивает их в подробные сообщения). Ключевые возможности:

* **fixtures** — инъекция зависимостей с областью действия (`scope="module"`).
* параметризация `@pytest.mark.parametrize`.
* скипы и xfail — маркировка непроходящих тестов.
* плагины: `pytest-cov`, `pytest-mock`.
  Запуск: `pytest -q`; отчёт JUnit: `pytest --junitxml=report.xml`.

---
